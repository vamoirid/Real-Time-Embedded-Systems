# Σημειώσεις για την Εργασία των Pthreads

Η εργασία μπορεί να χωριστεί σε μερικά λογικά διαφορετικά κομμάτια τα οποία αν αναλυθούν ξεχωριστά μπορούμε να την κατανοήσουμε αρκετά καλύτερα. Αυτά τα κομμάτια αφορούν αρχικά την **Υλοποίηση ουράς** το οποίο είναι το κομμάτι που κατασκευάζουμε τη δομή που θα χρησιμοποιήσουμε για να φτιάξουμε την ουρά ενώ στη συνέχεια έρχονται οι **Συναρτήσεις της ουράς** για να μπορέσουμε να διαχειριστούμε αυτή τη δομή που φτιάξαμε.

## Υλοποίηση ουράς - queue

Αρχικά ξεκινάμε με την κατασκευή ενός **struct** το οποίο θα περιέχει όλα τα απαραίτητα "υλικά" για να υλοποιήσουμε μια **ουρά-queue**. Από τι αποτελείται όμως η **queue**???

* _int_ **buf[**QUEUESIZE**]**: Η ίδια η **queue** με στατικό μέγεθος στην αρχή για λόγους ευκολίας.
* _long_ **head**, **tail**: Δύο μεταβλητές οι οποίες στην ουσία **δείχνουν** σε ποιο σημείο της ουράς βρίσκεται το πρώτο και το τελευταίο στοιχείο της ουράς ή αλλιώς το **head** και το **tail**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί είναι τύπου long?)**
* _int_ **full**, **empty**: Δύο μεταβλητές (**boolean** λογικής) οι οποίες μας ενημερώνουν για το αν η λίστα είναι γεμάτη ή άδεια δηλαδή **full** ή **empty**. 
* _pthread_mutex_t_ **\*mut**: Ένα **mutex**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί pointer?)**
* _pthread_cond_t_ **\*notFull**, **\*notEmpty**: Δύο μεταβλητές **cond**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί pointer?)**

Έτσι λοιπόν πλέον έχει ολοκληρωθεί η δομή της **queue** και περιέχει όλα τα στοιχεία τα οποία θα χρησιμοποιήσουμε. Η τελική δομή της λίστας φαίνεται παρακάτω:

```c
typedef struct {
    int buf[QUEUESIZE];
    long head, tail;
    int full, empty;
    pthread_mutex_t *mut;
    pthread_cond_t *notFull, *notEmpty;
    sem_t *sem;
}
```

## Συναρτήσεις Ουράς - Queue Functions

 Για να μπορέσουμε να διαχειριστούμε τη λίστα χρειαζόμαστε μερικές συναρτήσεις **εργαλεία** οι οποίες θα μας βοηθήσουν στον σκοπό αυτό. Αρχικά θα πρέπει να φτιάχνουμε μια ουρά και να αρχικοποιούμε όλες αυτές τις μεταβλητές που έχει η δομή της. Αυτό θα το πετύχουμε μέσω της συνάρτησης **queueInit**().

* #### queueInit()

```c
queue queueInit(void)
{
    queue *q;
    
    q = (queue *)malloc(sizeof(queue));
	if (q == NULL) return(NULL);
    
    q->head = 0;
    q->tail = 0;
    q->full = 0;
    q->empty = 1;
    q->mut = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t));
    pthread_mutex_init(q->mut, NULL);
    q->notFull = (pthread_cond_t *)malloc(sizeof(pthread_cond_t));
    pthread_cond_init(q->notFull, NULL);
    q->notEmpty = (pthread_cond_t *)malloc(sizeof(pthread_cond_t));
    pthread_cond_init(q->notEmpty, NULL);
    
    return (q);
}
```

Η παραπάνω συνάρτηση λοιπόν αρχικοποιεί όλες τις τιμές της ουράς που θα χρησιμοποιήσουμε στη συνέχεια. 

* #### queueAdd()

Αφού έχουμε κατασκευάσει και έχουμ αρχικοποιήσει μια ουρά πρέπει να βρούμε ένα τρόπο να **προσθέτουμε** στοιχεία σε αυτή. Αυτό το πετυχαίνουμε με την υλοποίηση της συνάρτησης **queueAdd**(). 

```C
void queueAdd(queue *q, int in)
{
    q->buf[q->tail] = in;
    q->tail;
    
    if (q->tail = QUEUESIZE)
        q->tail = 0;
    if (q->tail = q->head)
        q->full = 1;
    q->empty = 0;
    
    return;
}
```

Ο τρόπος με τον οποίο είναι υλοποιημένη η συνάρτηση **προυποθέτει ότι έχει ελεγχθεί από πριν** αν είναι γεμάτη η ουρά. Αν είναι γεμάτη η ουρά και πάμε να χρησιμοποιήσουμε τη συγκεκριμένη συνάρτηση τότε θα έχουμε _overflow_ και θα χάσουμε δεδομένα. Τα **ορίσματα** της συνάρτησης είναι η ίδια η ουρά και το στοιχείο το οποίο θέλουμε να προσθέσουμε σε αυτή. Η φιλοσοφία της είναι αυτή ενός **ring buffer**. Όσο βάζουμε στοιχεία αυξάνεται το **tail** μέχρι που κάποια στιγμή το **tail** == **head** οπότε και πλέον σε αυτό το σημείο λέμε ότι η ουρά είναι γεμάτη και αλλάζουμε την τιμή του flag **full** σε 1. Όταν η ουρά έχει φτάσει στην τιμή QUEUESIZE δηλαδή έχει φτάσει στον μέγιστο αριθμό τότε την ξαναθέτουμε ίση με 0 και συνεχίζεται η λειτουργία του **ring buffer**. Στο τέλος της συνάρτησης προφανώς και θέτουμε το flag **empty** σε 0 διότι μόλις προσθέσαμε ένα στοιχείο στην ουρά. 

* #### queueDel()

Αφού φτιάξαμε μια ρουτίνα που προσθέτει στοιχεία στην ουρά, πρέπει αντίστοιχα να φτιάξουμε και μια η οποία **αφαιρεί** στοιχεία από την ουρά. Αυτή η συνάρτηση ονομάζεται **queueDel**().

```c
void queueDel(queue *q, int *out)
{
	*out = q->buf[q->head];
    q->head++;
    
    if (q->head == QUEUESIZE)
        q->head = 0;
    if (q->head == q->tail)
        q->empty = 1;
    q->full = 0;
    
    return;
}
```

Ο τρόπος λειτουργίας προφανώς και είναι αντίστοιχος με αυτό της queueAdd(). **Προυποθέτει ότι έχει ελεγχθεί από πριν** ότι η ουρά δεν είναι άδεια. Αντίστοιχα με πριν οι τιμές του **head** αλλάζουν ανάλογα με το που βρίσκεται. 

Στην ουσία μπορούμε να σκεφτούμε τα **head**, **tail** ως 2 μεταβλητές οι οποίες η μία "κυνηγάει" την άλλη. Όσο το **tail** αυξάνεται χωρίς το **head** να παθαίνει το ίδιο, δηλαδή όσο προσθέτουμε στοιχεία στην ουρά, κάποια στιγμή το **tail** θα φτάσει το **head** και η ουρά θα είναι **full**. Αντίστοιχα όσο το **head** αυξάνεται χωρίς το **tail** να παθαίνει το ίδιο, δηλαδή όσο αφαιρούμε στοιχεία από την ουρά, κάποια στιγμή το **head** θα φτάσει το **tail** και η ουρά θα;

 είναι **empty**.

* #### queueDelete()

Όπως αρχικοποιούμε και κατασκευάζουμε μια ουρά πρέπει αντίστοιχα να έχουμε και έναν τρόπο για να τη διαγράφουμε από το πρόγραμμα μας. Από τη στιγμή που η ουρά είναι στατική και δεν καταχωρείται δυναμικά, τα μόνα κομμάτια τα οποία πρέπει να σβήσουμε για να απελευθερώσουμε είναι τα κομμάτια μνήμης που δεσμευτήκαμε για τα **mutex & condition variables** και τα **semaphores**. 

```c
void queueDelete(queue *q)
{
    pthread_mutex_destroy(q->mut);
    free(q->mut);
    pthread_condition_destroy(q->notFull);
    free(q->notFull);
    pthread_condition_destroy(q->notEmpty);
    free(q->notEmpty);
    sem_destroy(q->sem);
    free(q->sem);
    free(q);
}
```

Η παραπάνω συνάρτηση λοιπόν που μοιάζει με την queueDel() αλλά **δεν πρέπει** σε καμία περίπτωση να μπερδευτεί, καταστρέφει πρώτα με τις συναρτήσεις των αντίστοιχων βιβλιοθηκων τα αντίστοιχα "αντικείμενα" που αρχικοποίησε και μετά ελευθερώνει τη μνήμη που είχε δεσμευτεί για τη δημιουργία τους. Τέλος αποδεσμεύεται και το αρχικό κομμάτι μνήμης που είχε δεσμευτεί για τη δημιουργία της ουράς.

## Υλοποίηση Producer - Consumer

Η λογική με την οποία πρέπει να υλοποιηθεί η εργασία είναι ότι **p** producers θα πρέπει να διαθέτουν δουλειές και **q** consumers να τις εκτελούν. Αυτό για να το καταφέρουμε θα το χτίσουμε βήμα-βήμα μέχρι το τέλος. Αρχικά αντί να αναθέτουν **δουλειές**, θα αναθέτουν **ακέραιους αριθμούς** για να μειωθεί η πολυπλοκότητα. 

Η λογική τώρα της ανάθεσης και εκτέλεσης "δουλειών" από producers σε consumers πρέπει να ακολουθεί μερικά λογικά βήματα για να αποφευχθούν λογικά λάθη.  Αρχικά λοιπόν ο **producer** φτιάχνει έναν queue pointer για να μπορέσει να διαχειριστεί τα δεδομένα της queue που του δίνουμε.  Στη συνέχεια θέλουμε να βάλουμε ένα στοιχείο στην **queue** και μετά να τερματίσουμε το thread. Για να βάλουμε ένα στοιχείο στην **queue** πρέπει να διασφαλίσουμε ότι μόνο εμείς θα έχουμε access στην **queue** εκείνη τη στιγμή διότι αλλιώς αν ταυτόχρονα ένας βάζει και άλλος βγάζει θα δημιουργθούν απροσδιόριστες συμπεριφορές. Γι' αυτό το λόγο χρησιμοποιούμε το **mutex** για τη δουλειά αυτή. Τέλος αφού έχουμε ξεκλειδώσει το **mutex** πρέπει να ειδοποιήσουμε κάπως τον **consumer** ότι πλέον υπάρχει κάτι διαθέσιμο στην ουρά. Έτσι λοιπόν παίρνει τη σκυτάλη το _condition variable_ **notEmpty** και στέλνει ένα **signal**. Ο λόγος που χρησιμοποιείται η _pthread_cond_signal()_ και όχι η _pthread_cond_broadcast()_ είναι διότι η 2η θα στείλει σήμα σε **ΟΛΑ** τα threads που περιμένουν ενώ η 1η μόνο σε ένα. Έτσι εξασφαλίζουμε ότι δεν θα ξεκινήσουν ταυτόχρονα πάνω από 1 threads να εκτελούνε.

```c
void *producer(void *args)
{
    queue *info;
    fifo = (queue *)args;
    int value;
    
    pthread_mutex_lock(fifo->mut);
    
    while (fifo->full)
	{
		printf("producer: queue FULL.\n");
		pthread_cond_wait(fifo->notFull, fifo->mut);
	}
    
    queueAdd(fifo, value);
    pthread_mutex_unlock(fifo->mut);
    pthread_cond_signal(fifo->notEmpty);
    
    pthread_exit(0);
}
```

Αφού πλέον τοποθετούμε πράγματα στην ουρά μέσω του **producer** πρέπει να φτιάξουμε και το thread του **consumer** ο οποίος δέχεται τα κομμάτια της ουράς. Όπως και πριν πρέπει να δημιουργήσουμε έναν pointer queue για να μπορέσουμε να πάρουμε τα δεδομένα της ουράς. Στη συνέχεια πρέπει να περιμένουμε μέχρι να υπάρχει κάτι διαθέσιμο στη λίστα πράγμα το οποίο μπορούμε να πετύχουμε όπως και πριν μέσω των **condition variables** και μάλιστα χρησιμοποιώντας τη συνάρτηση **pthread_cond_wait**(). Όσο δεν υπάρχει κάτι διαθέσιμο το thread παραμένει σε αυτό το σημείο του κώδικα χωρίς να κάνει τίποτα και προχωράει μόνο όταν η τιμή του _conditon variable_ **notEmpty** αλλάξει μέσω της **pthread_cond_signal**() από τον producer. Στη συνέχεια όπως και πριν πρέπει ο consumer να διαγράφει κομμάτια αποκλειστικά χωρίς να έχει ταυτόχρονα κάποιος άλλος πρόσβαση στην ουρά. Γι' αυτό το λόγο πάλι χρησιμοποιούμε **mutex**.

```C
void *consumer(void *args)
{
    queue *fifo;
    fifo = (queue *)args;
    int value;
 
    pthread_mutex_lock(fifo->mut);
    
    while(fifo->empty)
	{
		printf("consumer: queue EMPTY.\n");
		pthread_cond_wait(fifo->notEmpty, fifo->mut);
	}
    
    queueDel(fifo, &value);
    pthread_mutex_unlock(fifo->mut);
    pthread_cond_signal(fifo->notFull);
    
    pthread_exit(0);
}
```

Επίσης η διαδικασία επιλογής του αριθμού των producers-consumers και εργασιών για να αυξάνεται σταδιακά η πολυπλοκότητα θα έχει ως εξής:

1. (producer, consumer, int) = (1, 1, 1)
2. (producer, consumer, int) = (1, 1, n)
3. (producer, consumer, int) = (1, q, n)
4. (producer, consumer, int) = (p, q, n)

#### (producer, consumer, int) = (1, 1, 1)

---

To συγκεκριμένο σύστημα είναι αυτό που περιγράψαμε πιο πάνω. 

#### (producer, consumer, int) = (1, 1, n)

---

Το συγκεκριμένο σύστημα προυποθέτει ότι έχουμε μια στατική δομή ουράς στην οποία βάζουμε στοιχεία μέσω του producer, βγάζουμε στοιχεία μέσω του consumer αλλά ταυτόχρονα ελέγχουμε να μην γίνει overflow/underflow στην ουρά. Για να το πετύχουμε αυτό αρχικά θα πρέπει να φτιάξουμε 2 **while(1)** λούπες στα 2 threads με τα οποία θα βάζουμε και θα βγάζουμε στοιχεία από το σύστημα **συνέχεια**. Όταν η ουρά θα είναι γεμάτη δηλαδή θα ισχύει ότι **fifo->full == 1** θα πρέπει το thread να περιμένει μέχρι να αδειάσει μια θέση για να μπορέσει να την τοποθετήσει. Αντίστοιχα όταν η ουρά θα είναι άδεια δηλαδή θα ισχύει **fifo->empty == 1** θα περιμένει ο consumer να μπει ένα στοιχείο για να μπορέσει να ξεκινήσει ο consumer. 

Ο κώδικας του **producer** γίνεται λοιπόν:

```c
void *producer(void *args)
{
	queue *fifo;
	fifo = (queue *)args;
	int i = 0;

	while (1)
	{
		pthread_mutex_lock(fifo->mut);

		while (fifo->full)
		{
			printf("producer: queue FULL.\n");
			pthread_cond_wait(fifo->notFull, fifo->mut);
		}

		queueAdd(fifo, i);
		i++;
		pthread_mutex_unlock(fifo->mut);
		printf("added i = %d\n", i);	
		pthread_cond_signal(fifo->notEmpty);
	}


	pthread_exit(0);
}
```

Και ο κώδικα του **consumer** γίνεται λοιπόν:

```c
void *consumer(void *args)
{
	queue *fifo;
	fifo = (queue *)args;
	int value;

	while(1)
	{
		pthread_mutex_lock(fifo->mut);

		while(fifo->empty)
		{
			printf("consumer: queue EMPTY.\n");
			pthread_cond_wait(fifo->notEmpty, fifo->mut);
		}
		
		queueDel(fifo, &value);
		pthread_mutex_unlock(fifo->mut);
		printf("deleted i = %d\n", value);	
		pthread_cond_signal(fifo->notFull);
	}

	pthread_exit(0);
}
```

#### (producer, consumer, int) = (1, q, n)

---

Το συγκεκριμένο σύστημα πλέον χειρίζεται από **q διαφορετικούς consumers** ή αλλιώς **q consumer threads**. Ο βέλτιστος αριθμός **q** θα προσδιοριστεί στη συνέχεια όταν χρειαστεί να μετρήσουμε το χρόνο που χρειάζεται από τη στιγμή που μια διεργασία φτάνει στη λίστα μέχρι τη στιγμή που φεύγει από αυτή.  Ουσιαστική διαφορά δεν υπάρχει στον κώδικα παρά μόνο στο σημείο όπου δημιουργούμε τα threads. Εκεί θα πρέπει να δημιουργήσουμε **q = NUM_CONS** threads.

#### (producer, consumer, int) = (p, q, n)

---

Το τελικό σύστημα είναι αυτό που πλέον αποτελείται από **p producer threads** τα οποία αναθέτουν συνεχόμενα _αριθμούς_ σε **q consumer threads**. Έτσι λοιπόν έχουμε φτάσει στο σημείο που πλέον πρέπει με κάποιον τρόπο αυτοί οι _αριθμοί_ να γίνουν **συναρτήσεις**.

## Work Functions

Στο σημείο αυτό πρέπει να γίνει η πιο σημαντική προσθήκη στον κώδικα μας. Ως τώρα αυτό που συνέβαινε μεταξύ **producers - consumers** ήταν ότι οι producers τοποθετούσαν αριθμούς μέσα σε μια ουρά και οι consumers τους βγάζανε. Αυτό που πρέπει να γίνει τώρα είναι ότι πρέπει αντί για αριθμούς, η ουρά θα πρέπει να αποτελείται από στοιχεία τύπου:

```c
struct workFunction {
  void *(*work)(void *);
  void *arg;
};
```

Αυτό που παρατηρούμε για τη συγκεκριμένη δομή είναι ότι στην ουσία είναι ένα function που μπορεί να γίνει **thread**. Το πρώτο στοιχείο είναι ένας **pointer** σε **function(void \*)** που επιστρέφει δεδομένα τύπου **void \*** και το δεύτερο στοιχείο είναι ένας **void** pointer ο οποίος αναφέρεται στο στοιχείο που περνάει μέσα στη συνάρτηση. Με το συγκεριμένο τρόπο δηλαδή θα μπορούσαμε θεωρητικά να έχουμε **threads** μέσα στην ίδια την ουρά! 

Ο λόγος για τον οποίο σχεδιάζουμε την ουρά με αυτό τον τρόπο είναι το ότι θέλουμε να φτιάξουμε ένα σύστημα στο οποίο **p producer threads** θα αναθέτουν δουλειές σε **q consumer threads** και στο τέλος να προσμετράται ο χρόνος από τη στιγμή ανάθεσης του producer μέχρι τη στιγμή εκκίνησης της συνάρτησης από τον consumer.

Από το σημείο λοιπόν που πριν η **ουρά** αποτελούταν από στοιχεία τύπου _int_ τώρα αποτελείται από στοιχεία τύπου _struct workFunction_. Κάθε **node** λοιπόν της ουράς είναι πλέον και από ένα _struct workFunction_ πράγμα το οποίο θα χρησιμοποιήσουμε για να κάνουμε πιο εύκολη τη δουλειά μας. Το συγκεκριμένο τύπο δεδομένων θα το ορίσουμε ως εξής:

```c
typedef struct workFunction {
    void *(*work)(void *);
    void *arg;
} workFunction;
```

Για να μπορέσουμε να έχουμε περισσότερη ευχέρεια στη χρήση του. Από εκεί και πέρα θα πρέπει να αλλάξουν οι εξής συναρτήσεις:

```c
void queueAdd(queue *q, workFunction in);
void queueDel(queue *q, workFunction *out);
```

Παράλληλα αντίστοιχα θα πρέπει να αλλάξει και η μεταβλητή **int value;** που υπήρχε μέσα στην _consumer()_ και να γίνει **workFunction receivedFunction;** έτσι ώστε να μπορούμε να λάβουμε τη διεύθυνση της συνάρτησης που υπάρχει μέσα στην ουρά. 

## Function Array

Για να μπορέσει να υλοποιηθεί το σύστημα πρέπει να φτιάξουμε μια "βάση δεδομένων" με πολλές συναρτήσεις έτσι ώστε να μπορούν να επιλέγουν από εκεί οι producers και να τις μεταφέρουν μέσα στην ουρά. Αυτή η "βάση δεδομένων" δεν είναι τίποτα άλλο από έναν **πίνακα** που θα περιέχει **pointers** που θα δείχνουν σε συναρτήσεις. Ένα μικρό παράδειγμα της υλοποίησης είναι το εξής:

```c
void* testFunA(void *sum)
{
	double i, tot_sum = 0;
	for(i = 0; i < 360000; i++) tot_sum += sin(i);
	sum = &tot_sum;

	return (sum);
}

void* testFunB(void *sum)
{
	double i, tot_sum = 0;	
	for(i = 0; i < 360000; i++) tot_sum += cos(i);
	sum = &tot_sum;

	return (sum);
}

void* testFunC(void *sum)
{
	double i, tot_sum = 0;
	for(i = 0; i < 360000; i++) tot_sum += tan(i);
	sum = &tot_sum;

	return (sum);
}
```

Οι παραπάνω είναι 3 συναρτήσεις οι οποίες θα δωθούν σε consumers για να εκτελεστούν. Το αν θα επιστραφούν οι τιμές sum στο calling thread δεν παίζει και πολύ μεγάλο ρόλο αφού εμείς τη δουλειά μας την έχουμε κάνει.  Αυτές οι συναρτήσεις θα αποθηκευτούν μέσα σε έναν πίνακα **global** ορισμένο για να έχουν όλοι πρόσβαση σε αυτόν. Οι αναθέσεις των τιμών πρέπει να γίνουν εσωτερικά της **main**().

```c
workFunction funcArray[3];  //****** global variable *****
```

ενώ στη συνέχεια μέσα στη **main**():

```c
funcArray[0].work = testFunA;
funcArray[1].work = testFunB;
funcArray[2].work = testFunC;
```

Αφού λοιπόν έχουμε φτιάξει έναν πρόχειρο πίνακα με συναρτήσεις πρέπει να βρούμε πως θα τον περάσουμε μέσα στην ουρά. Αυτό όπως και πριν γίνεται μέσω της συνάρτησης **queueAdd**() η οποία αναλαμβάνει την προσθήκη στοιχείων στη λίστα. Η συνάρτηση αυτή δέχεται ως πρώτο όρισμα τη διέυθυνση της ουράς (διότι είναι πίνακας) έτσι ώστε να μπορέσει να την επεξεγαστεί και ως 2ο όρισμα έχει πρέπει να δέχεται τη διεύθυνση της συνάρτησης μαζί με τη διεύθυνση της μεταβλητής που θα πρέπει να αποθηκευτεί. Αυτά τα 2 δεδομένα είναι το δεδομένο workFunction και γι αυτό το λόγο δεν χρειάζεται να περαστεί μέσω pointer. Έτσι μέσα στο **producer** έχουμε:

```c
queueAdd(fifo, funcArray[i]);
```

Αντίστοιχα τώρα για να "βγάλουμε" το στοιχείο από την ουρά πρέπει να χρησιμοποιήσουμε τη συνάρτηση **queueDel**() η οποία έχει το ίδιο πρώτο όρισμα με πριν αλλά στο 2ο χρειάζεται pointer! Και αυτό γιατί όταν φτιάχνουμε εμείς τη δομή workFunction δεν δεσμεύουμε δυναμικά χώρο στη μνήμη και έτσι πρέπει να περάσουμε τη διεύθυνση της δομής με σκοπό να την αφαιρέσουμε από το stack. Έτσι λοιπόν μέσα στο **consumer** έχουμε:

```c
workFunction receivedWorkFunc;
double *sum;

queueDel(fifo, &receivedWorkFunc); // Receive the workFunction
receivedWorkFunc.work(sum);        // Execute the function
```

Αφού πλέον μπορούμε και περνάμε συναρτήσεις από το ένα thread στο άλλο αυτό που έμεινε είναι μόνο να γίνεται η επιλογή τυχαία και στη συνέχεια να προσμετράται ο χρόνος από τη στιγμή που που ο producer βάζει τη συνάρτηση στην ουρά μέχρι τη στιγμή που ο consumer την παίρνει.