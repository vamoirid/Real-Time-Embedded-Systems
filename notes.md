# Σημειώσεις για την Εργασία των Pthreads

Η εργασία μπορεί να χωριστεί σε μερικά λογικά διαφορετικά κομμάτια τα οποία αν αναλυθούν ξεχωριστά μπορούμε να την κατανοήσουμε αρκετά καλύτερα. Αυτά τα κομμάτια αφορούν αρχικά την **Υλοποίηση ουράς** το οποίο είναι το κομμάτι που κατασκευάζουμε τη δομή που θα χρησιμοποιήσουμε για να φτιάξουμε την ουρά ενώ στη συνέχεια έρχονται οι **Συναρτήσεις της ουράς** για να μπορέσουμε να διαχειριστούμε αυτή τη δομή που φτιάξαμε.

## Υλοποίηση ουράς - queue

Αρχικά ξεκινάμε με την κατασκευή ενός **struct** το οποίο θα περιέχει όλα τα απαραίτητα "υλικά" για να υλοποιήσουμε μια **ουρά-queue**. Από τι αποτελείται όμως η **queue**???

* _int_ **buf[**QUEUESIZE**]**: Η ίδια η **queue** με στατικό μέγεθος στην αρχή για λόγους ευκολίας.
* _long_ **head**, **tail**: Δύο μεταβλητές οι οποίες στην ουσία **δείχνουν** σε ποιο σημείο της ουράς βρίσκεται το πρώτο και το τελευταίο στοιχείο της ουράς ή αλλιώς το **head** και το **tail**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί είναι τύπου long?)**
* _int_ **full**, **empty**: Δύο μεταβλητές (**boolean** λογικής) οι οποίες μας ενημερώνουν για το αν η λίστα είναι γεμάτη ή άδεια δηλαδή **full** ή **empty**. 
* _pthread_mutex_t_ **\*mut**: Ένα **mutex**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί pointer?)**
* _pthread_cond_t_ **\*notFull**, **\*notEmpty**: Δύο μεταβλητές **cond**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί pointer?)**
* _sem_t_ **\*sem_t**: Ένα **semaphore**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί pointer?)**

Έτσι λοιπόν πλέον έχει ολοκληρωθεί η δομή της **queue** και περιέχει όλα τα στοιχεία τα οποία θα χρησιμοποιήσουμε. Η τελική δομή της λίστας φαίνεται παρακάτω:

```c
typedef struct {
    int buf[QUEUESIZE];
    long head, tail;
    int full, empty;
    pthread_mutex_t *mut;
    pthread_cond_t *notFull, *notEmpty;
    sem_t *sem;
}
```

## Συναρτήσεις Ουράς - Queue Functions

 Για να μπορέσουμε να διαχειριστούμε τη λίστα χρειαζόμαστε μερικές συναρτήσεις **εργαλεία** οι οποίες θα μας βοηθήσουν στον σκοπό αυτό. Αρχικά θα πρέπει να φτιάχνουμε μια ουρά και να αρχικοποιούμε όλες αυτές τις μεταβλητές που έχει η δομή της. Αυτό θα το πετύχουμε μέσω της συνάρτησης **queueInit**().

* #### queueInit()

```c
queue queueInit(void)
{
    queue *q;
    
    q = (queue *)malloc(sizeof(queue));
	if (q == NULL) return(NULL);
    
    q->head = 0;
    q->tail = 0;
    q->full = 0;
    q->empty = 1;
    q->mut = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t));
    pthread_mutex_init(q->mut, NULL);
    q->notFull = (pthread_cond_t *)malloc(sizeof(pthread_cond_t));
    pthread_cond_init(q->notFull, q->mut);
    q->notEmpty = (pthread_cond_t *)malloc(sizeof(pthread_cond_t));
    pthread_cond_init(q->notEmpty, q->mut);
    q->sem = (sem_t *)malloc(sizeof(sem_t));
    sem_init(q->sem, 0, 0);
    
    return (q);
}
```

Η παραπάνω συνάρτηση λοιπόν αρχικοποιεί όλες τις τιμές της ουράς που θα χρησιμοποιήσουμε στη συνέχεια. Ο λόγος που βάζουμε 0 στο **value** της **sem_init**() θα γίνει κατανοητός αργότερα. 

* #### queueAdd()

Αφού έχουμε κατασκευάσει και έχουμ αρχικοποιήσει μια ουρά πρέπει να βρούμε ένα τρόπο να **προσθέτουμε** στοιχεία σε αυτή. Αυτό το πετυχαίνουμε με την υλοποίηση της συνάρτησης **queueAdd**(). 

```C
void queueAdd(queue *q, int in)
{
    q->buf[q->tail] = in;
    q->tail;
    
    if (q->tail = QUEUESIZE)
        q->tail = 0;
    if (q->tail = q->head)
        q->full = 1;
    q->empty = 0;
    
    return;
}
```

Ο τρόπος με τον οποίο είναι υλοποιημένη η συνάρτηση **προυποθέτει ότι έχει ελεγχθεί από πριν** αν είναι γεμάτη η ουρά. Αν είναι γεμάτη η ουρά και πάμε να χρησιμοποιήσουμε τη συγκεκριμένη συνάρτηση τότε θα έχουμε _overflow_ και θα χάσουμε δεδομένα. Τα **ορίσματα** της συνάρτησης είναι η ίδια η ουρά και το στοιχείο το οποίο θέλουμε να προσθέσουμε σε αυτή. Η φιλοσοφία της είναι αυτή ενός **ring buffer**. Όσο βάζουμε στοιχεία αυξάνεται το **tail** μέχρι που κάποια στιγμή το **tail** == **head** οπότε και πλέον σε αυτό το σημείο λέμε ότι η ουρά είναι γεμάτη και αλλάζουμε την τιμή του flag **full** σε 1. Όταν η ουρά έχει φτάσει στην τιμή QUEUESIZE δηλαδή έχει φτάσει στον μέγιστο αριθμό τότε την ξαναθέτουμε ίση με 0 και συνεχίζεται η λειτουργία του **ring buffer**. Στο τέλος της συνάρτησης προφανώς και θέτουμε το flag **empty** σε 0 διότι μόλις προσθέσαμε ένα στοιχείο στην ουρά. 

* #### queueDel()

Αφού φτιάξαμε μια ρουτίνα που προσθέτει στοιχεία στην ουρά, πρέπει αντίστοιχα να φτιάξουμε και μια η οποία **αφαιρεί** στοιχεία από την ουρά. Αυτή η συνάρτηση ονομάζεται **queueDel**().

```c
void queueDel(queue *q, int *out)
{
	*out = q->buf[q->head];
    q->head++;
    
    if (q->head == QUEUESIZE)
        q->head = 0;
    if (q->head == q->tail)
        q->empty = 1;
    q->full = 0;
    
    return;
}
```

Ο τρόπος λειτουργίας προφανώς και είναι αντίστοιχος με αυτό της queueAdd(). **Προυποθέτει ότι έχει ελεγχθεί από πριν** ότι η ουρά δεν είναι άδεια. Αντίστοιχα με πριν οι τιμές του **head** αλλάζουν ανάλογα με το που βρίσκεται. 

Στην ουσία μπορούμε να σκεφτούμε τα **head**, **tail** ως 2 μεταβλητές οι οποίες η μία "κυνηγάει" την άλλη. Όσο το **tail** αυξάνεται χωρίς το **head** να παθαίνει το ίδιο, δηλαδή όσο προσθέτουμε στοιχεία στην ουρά, κάποια στιγμή το **tail** θα φτάσει το **head** και η ουρά θα είναι **full**. Αντίστοιχα όσο το **head** αυξάνεται χωρίς το **tail** να παθαίνει το ίδιο, δηλαδή όσο αφαιρούμε στοιχεία από την ουρά, κάποια στιγμή το **head** θα φτάσει το **tail** και η ουρά θα;

 είναι **empty**.

* #### queueDelete()

Όπως αρχικοποιούμε και κατασκευάζουμε μια ουρά πρέπει αντίστοιχα να έχουμε και έναν τρόπο για να τη διαγράφουμε από το πρόγραμμα μας. Από τη στιγμή που η ουρά είναι στατική και δεν καταχωρείται δυναμικά, τα μόνα κομμάτια τα οποία πρέπει να σβήσουμε για να απελευθερώσουμε είναι τα κομμάτια μνήμης που δεσμευτήκαμε για τα **mutex & condition variables** και τα **semaphores**. 

```c
void queueDelete(queue *q)
{
    pthread_mutex_destroy(q->mut);
    free(q->mut);
    pthread_condition_destroy(q->notFull);
    free(q->notFull);
    pthread_condition_destroy(q->notEmpty);
    free(q->notEmpty);
    sem_destroy(q->sem);
    free(q->sem);
    free(q);
}
```

Η παραπάνω συνάρτηση λοιπόν που μοιάζει με την queueDel() αλλά **δεν πρέπει** σε καμία περίπτωση να μπερδευτεί, καταστρέφει πρώτα με τις συναρτήσεις των αντίστοιχων βιβλιοθηκων τα αντίστοιχα "αντικείμενα" που αρχικοποίησε και μετά ελευθερώνει τη μνήμη που είχε δεσμευτεί για τη δημιουργία τους. Τέλος αποδεσμεύεται και το αρχικό κομμάτι μνήμης που είχε δεσμευτεί για τη δημιουργία της ουράς.