# Σημειώσεις για την Εργασία των Pthreads

Η εργασία μπορεί να χωριστεί σε μερικά λογικά διαφορετικά κομμάτια τα οποία αν αναλυθούν ξεχωριστά μπορούμε να την κατανοήσουμε αρκετά καλύτερα. Αυτά τα κομμάτια αφορούν αρχικά την **Υλοποίηση ουράς** το οποίο είναι το κομμάτι που κατασκευάζουμε τη δομή που θα χρησιμοποιήσουμε για να φτιάξουμε την ουρά ενώ στη συνέχεια έρχονται οι **Συναρτήσεις της ουράς** για να μπορέσουμε να διαχειριστούμε αυτή τη δομή που φτιάξαμε.

## Υλοποίηση ουράς - queue

Αρχικά ξεκινάμε με την κατασκευή ενός **struct** το οποίο θα περιέχει όλα τα απαραίτητα "υλικά" για να υλοποιήσουμε μια **ουρά-queue**. Από τι αποτελείται όμως η **queue**???

* _int_ **buf[**QUEUESIZE**]**: Η ίδια η **queue** με στατικό μέγεθος στην αρχή για λόγους ευκολίας.
* _long_ **head**, **tail**: Δύο μεταβλητές οι οποίες στην ουσία **δείχνουν** σε ποιο σημείο της ουράς βρίσκεται το πρώτο και το τελευταίο στοιχείο της ουράς ή αλλιώς το **head** και το **tail**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί είναι τύπου long?)**
* _int_ **full**, **empty**: Δύο μεταβλητές (**boolean** λογικής) οι οποίες μας ενημερώνουν για το αν η λίστα είναι γεμάτη ή άδεια δηλαδή **full** ή **empty**. 
* _pthread_mutex_t_ **\*mut**: Ένα **mutex**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί pointer?)**
* _pthread_cond_t_ **\*notFull**, **\*notEmpty**: Δύο μεταβλητές **cond**. **(\*\*\*ΑΠΟΡΙΑ\*\*\*: Γιατί pointer?)**

Έτσι λοιπόν πλέον έχει ολοκληρωθεί η δομή της **queue** και περιέχει όλα τα στοιχεία τα οποία θα χρησιμοποιήσουμε. Η τελική δομή της λίστας φαίνεται παρακάτω:

```c
typedef struct {
    int buf[QUEUESIZE];
    long head, tail;
    int full, empty;
    pthread_mutex_t *mut;
    pthread_cond_t *notFull, *notEmpty;
    sem_t *sem;
}
```

## Συναρτήσεις Ουράς - Queue Functions

 Για να μπορέσουμε να διαχειριστούμε τη λίστα χρειαζόμαστε μερικές συναρτήσεις **εργαλεία** οι οποίες θα μας βοηθήσουν στον σκοπό αυτό. Αρχικά θα πρέπει να φτιάχνουμε μια ουρά και να αρχικοποιούμε όλες αυτές τις μεταβλητές που έχει η δομή της. Αυτό θα το πετύχουμε μέσω της συνάρτησης **queueInit**().

* #### queueInit()

```c
queue queueInit(void)
{
    queue *q;
    
    q = (queue *)malloc(sizeof(queue));
	if (q == NULL) return(NULL);
    
    q->head = 0;
    q->tail = 0;
    q->full = 0;
    q->empty = 1;
    q->mut = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t));
    pthread_mutex_init(q->mut, NULL);
    q->notFull = (pthread_cond_t *)malloc(sizeof(pthread_cond_t));
    pthread_cond_init(q->notFull, NULL);
    q->notEmpty = (pthread_cond_t *)malloc(sizeof(pthread_cond_t));
    pthread_cond_init(q->notEmpty, NULL);
    
    return (q);
}
```

Η παραπάνω συνάρτηση λοιπόν αρχικοποιεί όλες τις τιμές της ουράς που θα χρησιμοποιήσουμε στη συνέχεια. 

* #### queueAdd()

Αφού έχουμε κατασκευάσει και έχουμ αρχικοποιήσει μια ουρά πρέπει να βρούμε ένα τρόπο να **προσθέτουμε** στοιχεία σε αυτή. Αυτό το πετυχαίνουμε με την υλοποίηση της συνάρτησης **queueAdd**(). 

```C
void queueAdd(queue *q, int in)
{
    q->buf[q->tail] = in;
    q->tail;
    
    if (q->tail = QUEUESIZE)
        q->tail = 0;
    if (q->tail = q->head)
        q->full = 1;
    q->empty = 0;
    
    return;
}
```

Ο τρόπος με τον οποίο είναι υλοποιημένη η συνάρτηση **προυποθέτει ότι έχει ελεγχθεί από πριν** αν είναι γεμάτη η ουρά. Αν είναι γεμάτη η ουρά και πάμε να χρησιμοποιήσουμε τη συγκεκριμένη συνάρτηση τότε θα έχουμε _overflow_ και θα χάσουμε δεδομένα. Τα **ορίσματα** της συνάρτησης είναι η ίδια η ουρά και το στοιχείο το οποίο θέλουμε να προσθέσουμε σε αυτή. Η φιλοσοφία της είναι αυτή ενός **ring buffer**. Όσο βάζουμε στοιχεία αυξάνεται το **tail** μέχρι που κάποια στιγμή το **tail** == **head** οπότε και πλέον σε αυτό το σημείο λέμε ότι η ουρά είναι γεμάτη και αλλάζουμε την τιμή του flag **full** σε 1. Όταν η ουρά έχει φτάσει στην τιμή QUEUESIZE δηλαδή έχει φτάσει στον μέγιστο αριθμό τότε την ξαναθέτουμε ίση με 0 και συνεχίζεται η λειτουργία του **ring buffer**. Στο τέλος της συνάρτησης προφανώς και θέτουμε το flag **empty** σε 0 διότι μόλις προσθέσαμε ένα στοιχείο στην ουρά. 

* #### queueDel()

Αφού φτιάξαμε μια ρουτίνα που προσθέτει στοιχεία στην ουρά, πρέπει αντίστοιχα να φτιάξουμε και μια η οποία **αφαιρεί** στοιχεία από την ουρά. Αυτή η συνάρτηση ονομάζεται **queueDel**().

```c
void queueDel(queue *q, int *out)
{
	*out = q->buf[q->head];
    q->head++;
    
    if (q->head == QUEUESIZE)
        q->head = 0;
    if (q->head == q->tail)
        q->empty = 1;
    q->full = 0;
    
    return;
}
```

Ο τρόπος λειτουργίας προφανώς και είναι αντίστοιχος με αυτό της queueAdd(). **Προυποθέτει ότι έχει ελεγχθεί από πριν** ότι η ουρά δεν είναι άδεια. Αντίστοιχα με πριν οι τιμές του **head** αλλάζουν ανάλογα με το που βρίσκεται. 

Στην ουσία μπορούμε να σκεφτούμε τα **head**, **tail** ως 2 μεταβλητές οι οποίες η μία "κυνηγάει" την άλλη. Όσο το **tail** αυξάνεται χωρίς το **head** να παθαίνει το ίδιο, δηλαδή όσο προσθέτουμε στοιχεία στην ουρά, κάποια στιγμή το **tail** θα φτάσει το **head** και η ουρά θα είναι **full**. Αντίστοιχα όσο το **head** αυξάνεται χωρίς το **tail** να παθαίνει το ίδιο, δηλαδή όσο αφαιρούμε στοιχεία από την ουρά, κάποια στιγμή το **head** θα φτάσει το **tail** και η ουρά θα;

 είναι **empty**.

* #### queueDelete()

Όπως αρχικοποιούμε και κατασκευάζουμε μια ουρά πρέπει αντίστοιχα να έχουμε και έναν τρόπο για να τη διαγράφουμε από το πρόγραμμα μας. Από τη στιγμή που η ουρά είναι στατική και δεν καταχωρείται δυναμικά, τα μόνα κομμάτια τα οποία πρέπει να σβήσουμε για να απελευθερώσουμε είναι τα κομμάτια μνήμης που δεσμευτήκαμε για τα **mutex & condition variables** και τα **semaphores**. 

```c
void queueDelete(queue *q)
{
    pthread_mutex_destroy(q->mut);
    free(q->mut);
    pthread_condition_destroy(q->notFull);
    free(q->notFull);
    pthread_condition_destroy(q->notEmpty);
    free(q->notEmpty);
    sem_destroy(q->sem);
    free(q->sem);
    free(q);
}
```

Η παραπάνω συνάρτηση λοιπόν που μοιάζει με την queueDel() αλλά **δεν πρέπει** σε καμία περίπτωση να μπερδευτεί, καταστρέφει πρώτα με τις συναρτήσεις των αντίστοιχων βιβλιοθηκων τα αντίστοιχα "αντικείμενα" που αρχικοποίησε και μετά ελευθερώνει τη μνήμη που είχε δεσμευτεί για τη δημιουργία τους. Τέλος αποδεσμεύεται και το αρχικό κομμάτι μνήμης που είχε δεσμευτεί για τη δημιουργία της ουράς.

## Υλοποίηση Producer - Consumer

Η λογική με την οποία πρέπει να υλοποιηθεί η εργασία είναι ότι **p** producers θα πρέπει να διαθέτουν δουλειές και **q** consumers να τις εκτελούν. Αυτό για να το καταφέρουμε θα το χτίσουμε βήμα-βήμα μέχρι το τέλος. Αρχικά αντί να αναθέτουν **δουλειές**, θα αναθέτουν **ακέραιους αριθμούς** για να μειωθεί η πολυπλοκότητα. 

Η λογική τώρα της ανάθεσης και εκτέλεσης "δουλειών" από producers σε consumers πρέπει να ακολουθεί μερικά λογικά βήματα για να αποφευχθούν λογικά λάθη.  Αρχικά λοιπόν ο **producer** φτιάχνει έναν queue pointer για να μπορέσει να διαχειριστεί τα δεδομένα της queue που του δίνουμε.  Στη συνέχεια θέλουμε να βάλουμε ένα στοιχείο στην **queue** και μετά να τερματίσουμε το thread. Για να βάλουμε ένα στοιχείο στην **queue** πρέπει να διασφαλίσουμε ότι μόνο εμείς θα έχουμε access στην **queue** εκείνη τη στιγμή διότι αλλιώς αν ταυτόχρονα ένας βάζει και άλλος βγάζει θα δημιουργθούν απροσδιόριστες συμπεριφορές. Γι' αυτό το λόγο χρησιμοποιούμε το **mutex** για τη δουλειά αυτή. Τέλος αφού έχουμε ξεκλειδώσει το **mutex** πρέπει να ειδοποιήσουμε κάπως τον **consumer** ότι πλέον υπάρχει κάτι διαθέσιμο στην ουρά. Έτσι λοιπόν παίρνει τη σκυτάλη το _condition variable_ **notEmpty** και στέλνει ένα **signal**. Ο λόγος που χρησιμοποιείται η _pthread_cond_signal()_ και όχι η _pthread_cond_broadcast()_ είναι διότι η 2η θα στείλει σήμα σε **ΟΛΑ** τα threads που περιμένουν ενώ η 1η μόνο σε ένα. Έτσι εξασφαλίζουμε ότι δεν θα ξεκινήσουν ταυτόχρονα πάνω από 1 threads να εκτελούνε.

```c
void *producer(void *args)
{
    queue *info;
    fifo = (queue *)args;
    int value;
    
    pthread_mutex_lock(fifo->mut);
    
    while (fifo->full)
	{
		printf("producer: queue FULL.\n");
		pthread_cond_wait(fifo->notFull, fifo->mut);
	}
    
    queueAdd(fifo, value);
    pthread_mutex_unlock(fifo->mut);
    pthread_cond_signal(fifo->notEmpty);
    
    pthread_exit(0);
}
```

Αφού πλέον τοποθετούμε πράγματα στην ουρά μέσω του **producer** πρέπει να φτιάξουμε και το thread του **consumer** ο οποίος δέχεται τα κομμάτια της ουράς. Όπως και πριν πρέπει να δημιουργήσουμε έναν pointer queue για να μπορέσουμε να πάρουμε τα δεδομένα της ουράς. Στη συνέχεια πρέπει να περιμένουμε μέχρι να υπάρχει κάτι διαθέσιμο στη λίστα πράγμα το οποίο μπορούμε να πετύχουμε όπως και πριν μέσω των **condition variables** και μάλιστα χρησιμοποιώντας τη συνάρτηση **pthread_cond_wait**(). Όσο δεν υπάρχει κάτι διαθέσιμο το thread παραμένει σε αυτό το σημείο του κώδικα χωρίς να κάνει τίποτα και προχωράει μόνο όταν η τιμή του _conditon variable_ **notEmpty** αλλάξει μέσω της **pthread_cond_signal**() από τον producer. Στη συνέχεια όπως και πριν πρέπει ο consumer να διαγράφει κομμάτια αποκλειστικά χωρίς να έχει ταυτόχρονα κάποιος άλλος πρόσβαση στην ουρά. Γι' αυτό το λόγο πάλι χρησιμοποιούμε **mutex**.

```C
void *consumer(void *args)
{
    queue *fifo;
    fifo = (queue *)args;
    int value;
 
    pthread_mutex_lock(fifo->mut);
    
    while(fifo->empty)
	{
		printf("consumer: queue EMPTY.\n");
		pthread_cond_wait(fifo->notEmpty, fifo->mut);
	}
    
    queueDel(fifo, &value);
    pthread_mutex_unlock(fifo->mut);
    pthread_cond_signal(fifo->notFull);
    
    pthread_exit(0);
}
```

Επίσης η διαδικασία επιλογής του αριθμού των producers-consumers και εργασιών για να αυξάνεται σταδιακά η πολυπλοκότητα θα έχει ως εξής:

1. (producer, consumer, int) = (1, 1, 1)
2. (producer, consumer, int) = (1, 1, n)
3. (producer, consumer, int) = (1, q, n)
4. (producer, consumer, int) = (p, q, n)

#### (producer, consumer, int) = (1, 1, 1)

---

To συγκεκριμένο σύστημα είναι αυτό που περιγράψαμε πιο πάνω. 

#### (producer, consumer, int) = (1, 1, n)

---

Το συγκεκριμένο σύστημα προυποθέτει ότι έχουμε μια στατική δομή ουράς στην οποία βάζουμε στοιχεία μέσω του producer, βγάζουμε στοιχεία μέσω του consumer αλλά ταυτόχρονα ελέγχουμε να μην γίνει overflow/underflow στην ουρά. Για να το πετύχουμε αυτό αρχικά θα πρέπει να φτιάξουμε 2 **while(1)** λούπες στα 2 threads με τα οποία θα βάζουμε και θα βγάζουμε στοιχεία από το σύστημα **συνέχεια**. Όταν η ουρά θα είναι γεμάτη δηλαδή θα ισχύει ότι **fifo->full == 1** θα πρέπει το thread να περιμένει μέχρι να αδειάσει μια θέση για να μπορέσει να την τοποθετήσει. Αντίστοιχα όταν η ουρά θα είναι άδεια δηλαδή θα ισχύει **fifo->empty == 1** θα περιμένει ο consumer να μπει ένα στοιχείο για να μπορέσει να ξεκινήσει ο consumer. 

Ο κώδικας του **producer** γίνεται λοιπόν:

```c
void *producer(void *args)
{
	queue *fifo;
	fifo = (queue *)args;
	int i = 0;

	while (1)
	{
		pthread_mutex_lock(fifo->mut);

		while (fifo->full)
		{
			printf("producer: queue FULL.\n");
			pthread_cond_wait(fifo->notFull, fifo->mut);
		}

		queueAdd(fifo, i);
		i++;
		pthread_mutex_unlock(fifo->mut);
		printf("added i = %d\n", i);	
		pthread_cond_signal(fifo->notEmpty);
	}


	pthread_exit(0);
}
```

Και ο κώδικα του **consumer** γίνεται λοιπόν:

```c
void *consumer(void *args)
{
	queue *fifo;
	fifo = (queue *)args;
	int value;

	while(1)
	{
		pthread_mutex_lock(fifo->mut);

		while(fifo->empty)
		{
			printf("consumer: queue EMPTY.\n");
			pthread_cond_wait(fifo->notEmpty, fifo->mut);
		}
		
		queueDel(fifo, &value);
		pthread_mutex_unlock(fifo->mut);
		printf("deleted i = %d\n", value);	
		pthread_cond_signal(fifo->notFull);
	}

	pthread_exit(0);
}
```

#### (producer, consumer, int) = (1, q, n)

---

Το συγκεκριμένο σύστημα πλέον χειρίζεται από **q διαφορετικούς consumers** ή αλλιώς **q consumer threads**. Ο βέλτιστος αριθμός **q** θα προσδιοριστεί στη συνέχεια όταν χρειαστεί να μετρήσουμε το χρόνο που χρειάζεται από τη στιγμή που μια διεργασία φτάνει στη λίστα μέχρι τη στιγμή που φεύγει από αυτή.  Ουσιαστική διαφορά δεν υπάρχει στον κώδικα παρά μόνο στο σημείο όπου δημιουργούμε τα threads. Εκεί θα πρέπει να δημιουργήσουμε **q = NUM_CONS** threads.

#### (producer, consumer, int) = (p, q, n)

---

Το τελικό σύστημα είναι αυτό που πλέον αποτελείται από **p producer threads** τα οποία αναθέτουν συνεχόμενα _αριθμούς_ σε **q consumer threads**. Έτσι λοιπόν έχουμε φτάσει στο σημείο που πλέον πρέπει με κάποιον τρόπο αυτοί οι _αριθμοί_ να γίνουν **συναρτήσεις**.

## Work Functions

Στο σημείο αυτό πρέπει να γίνει η πιο σημαντική προσθήκη στον κώδικα μας. Ως τώρα αυτό που συνέβαινε μεταξύ **producers - consumers** ήταν ότι οι producers τοποθετούσαν αριθμούς μέσα σε μια ουρά και οι consumers τους βγάζανε. Αυτό που πρέπει να γίνει τώρα είναι ότι πρέπει αντί για αριθμούς, η ουρά θα πρέπει να αποτελείται από στοιχεία τύπου:

```c
struct workFunction {
  void * (*work)(void *);
  void * arg;
}
```

